# Example: Code Analysis Toolkit (Pattern 2 - Function-Based Workflow)

Demonstrates Pattern 2 (Function-Based Workflow) providing a toolkit of analysis functions for code inspection.

```xml
<functions>
  <!-- CRITICAL: Both DoR/DoD check elements below are MANDATORY -->
  <execute_dor_checks_before_starting/>
  <schedule_dod_checks_with_sub_agent_before_starting/>
  
  <function name="analyze_dependencies">
    <purpose>Extract and categorize project dependencies</purpose>
    <when_to_use>When understanding project structure or checking for outdated packages</when_to_use>
    <inputs>
      - project_root: Root directory of the project
      - package_file: Name of package manifest (e.g., pyproject.toml, package.json)
    </inputs>
    <action>
      1. Locate package manifest file
      2. Parse dependencies section
      3. Categorize as direct vs dev dependencies
      4. Check for version constraints
    </action>
    <outputs>
      - dependencies: list of {name, version, category, constraint_type}
      - dependency_count: total number of dependencies
    </outputs>
  </function>

  <function name="analyze_imports">
    <purpose>Map import relationships within codebase</purpose>
    <when_to_use>When understanding module coupling or planning refactoring</when_to_use>
    <inputs>
      - source_files: List of source files to analyze
      - include_stdlib: Whether to include standard library imports
    </inputs>
    <action>
      1. Parse each source file for import statements
      2. Resolve relative imports to absolute paths
      3. Build import graph
      4. Identify circular dependencies
    </action>
    <constraints>
      - CRITICAL: Flag circular dependencies
    </constraints>
    <outputs>
      - import_graph: mapping of file to its imports
      - circular_deps: list of circular dependency chains
      - external_deps: list of external package imports
    </outputs>
  </function>

  <function name="analyze_complexity">
    <purpose>Calculate code complexity metrics</purpose>
    <when_to_use>When evaluating code quality or identifying refactoring candidates</when_to_use>
    <inputs>
      - file_path: Source file to analyze
      - threshold: Complexity threshold for flagging
    </inputs>
    <action>
      1. Parse source file AST
      2. Calculate cyclomatic complexity per function
      3. Calculate cognitive complexity per function
      4. Flag functions exceeding threshold
    </action>
    <outputs>
      - functions: list of {name, cyclomatic, cognitive, loc}
      - high_complexity: list of functions exceeding threshold
      - file_average: average complexity across all functions
    </outputs>
  </function>

  <function name="analyze_test_coverage">
    <purpose>Identify untested code paths</purpose>
    <when_to_use>When improving test coverage or identifying testing gaps</when_to_use>
    <inputs>
      - source_dir: Directory containing source code
      - test_dir: Directory containing test files
    </inputs>
    <action>
      1. Map test files to source files by naming convention
      2. Parse test files for test functions
      3. Identify source files without corresponding tests
      4. Identify public functions without test coverage
    </action>
    <outputs>
      - coverage_map: mapping of source files to test files
      - untested_files: list of source files without tests
      - untested_functions: list of public functions without tests
    </outputs>
  </function>

</functions>
```
