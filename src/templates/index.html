{% extends "base.html" %}

{% block title %}X IPE - AI Native Integrated Project Environment{% endblock %}

{% block body %}
<!-- Page Root: 3-row vertical layout (top menu, middle, bottom console) -->
<div class="page-root" id="page-root">
    <!-- ROW 1: Top Menu Bar -->
    <header class="top-menu">
        <div class="brand">
            <span class="brand-name">X IPE</span>
            <span class="brand-subtitle">AI native integrated project environment</span>
        </div>
        <div class="menu-actions">
            <a href="/settings" class="menu-link" title="Settings">
                <i class="bi bi-gear"></i>
                <span>Settings</span>
            </a>
        </div>
    </header>

    <!-- ROW 2: Middle Section (sidebar + content) -->
    <div class="middle-section" id="middle-section">
        <!-- LEFT: Sidebar Navigation -->
        <nav class="sidebar" id="sidebar">
            <!-- Project Switcher (FEATURE-006 v2.0) -->
            <div class="project-switcher">
                <select id="project-select" title="Switch project folder">
                    <option value="">Loading projects...</option>
                </select>
            </div>
            
            <div class="sidebar-content" id="sidebar-content">
                <div class="loading-spinner">
                    <div class="spinner-border spinner-border-sm text-light" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                </div>
            </div>
        </nav>
    
        <!-- RIGHT: Content Area -->
        <main class="content-area">
            <div class="content-header">
                <nav aria-label="breadcrumb">
                    <ol class="breadcrumb" id="breadcrumb">
                        <li class="breadcrumb-item active">Select a file</li>
                    </ol>
                </nav>
                <div class="header-actions d-flex align-items-center gap-2">
                    <!-- FEATURE-004: Live Refresh Toggle -->
                    <div class="auto-refresh-toggle d-flex align-items-center gap-1">
                        <label class="form-check-label small text-muted" for="auto-refresh-toggle">
                            <i class="bi bi-arrow-repeat"></i> Auto-refresh
                        </label>
                        <div class="form-check form-switch mb-0">
                            <input class="form-check-input" type="checkbox" 
                                   id="auto-refresh-toggle" checked
                                   title="Toggle automatic content refresh">
                        </div>
                    </div>
                    <!-- FEATURE-003: Content Editor Actions -->
                    <div class="editor-actions d-none" id="editor-actions">
                        <button class="btn btn-sm btn-outline-primary" id="btn-edit" title="Edit file (Ctrl+E)">
                            <i class="bi bi-pencil"></i> Edit
                        </button>
                        <button class="btn btn-sm btn-primary d-none" id="btn-save" title="Save file (Ctrl+S)">
                            <i class="bi bi-check-lg"></i> Save
                        </button>
                        <button class="btn btn-sm btn-outline-secondary d-none" id="btn-cancel" title="Cancel editing (Esc)">
                            <i class="bi bi-x-lg"></i> Cancel
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="content-body" id="content-body">
                <div class="content-placeholder">
                    <i class="bi bi-file-earmark-text"></i>
                    <h5>Select a file to view</h5>
                    <p class="text-muted">Choose a file from the sidebar to view its contents</p>
                </div>
            </div>
        </main>
    </div><!-- end middle-section -->

    <!-- ROW 3: Interactive Console - Terminal Panel -->
    <div class="terminal-panel collapsed" id="terminal-panel">
        <div class="terminal-resize-handle" id="terminal-resize-handle"></div>
        <div class="terminal-header" id="terminal-header">
            <div class="terminal-title">
                <i class="bi bi-terminal"></i>
                <span>Console</span>
            </div>
            <div class="terminal-status">
                <span class="status-indicator" id="terminal-status-indicator"></span>
                <span class="status-text" id="terminal-status-text">Connecting...</span>
            </div>
            <div class="terminal-actions">
                <button id="add-terminal-btn" title="Add Terminal">+</button>
                <button id="terminal-zen-btn" title="Zen Mode">
                    <i class="bi bi-arrows-fullscreen"></i>
                </button>
                <button id="terminal-toggle" title="Toggle terminal">
                    <i class="bi bi-chevron-up"></i>
                </button>
            </div>
        </div>
        <div class="terminal-panes" id="terminal-panes">
            <!-- Panes inserted dynamically by TerminalManager -->
        </div>
    </div><!-- end terminal-panel -->
</div><!-- end page-root -->

<!-- Toast Container for notifications -->
<div class="toast-container" id="toast-container"></div>
{% endblock %}

{% block extra_js %}
<script>
/**
 * Content Renderer
 * FEATURE-002: Content Viewer
 * 
 * Renders file content with appropriate formatting:
 * - Markdown files: parsed with marked.js, syntax highlighting, Mermaid diagrams
 * - Code files: syntax highlighting with highlight.js
 * - Other files: plain text
 */
class ContentRenderer {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.currentPath = null;
        this.initMermaid();
        this.initMarked();
    }
    
    /**
     * Initialize Mermaid.js configuration
     */
    initMermaid() {
        if (typeof mermaid !== 'undefined') {
            mermaid.initialize({
                startOnLoad: false,
                theme: 'default',
                securityLevel: 'loose'
            });
        }
    }
    
    /**
     * Initialize Marked.js configuration with highlight.js
     */
    initMarked() {
        if (typeof marked !== 'undefined') {
            marked.setOptions({
                highlight: function(code, lang) {
                    if (typeof hljs !== 'undefined' && lang && hljs.getLanguage(lang)) {
                        try {
                            return hljs.highlight(code, { language: lang }).value;
                        } catch (e) {
                            console.error('Highlight error:', e);
                        }
                    }
                    return code;
                },
                breaks: true,
                gfm: true
            });
        }
    }
    
    /**
     * Load and render file content
     */
    async load(path) {
        if (!path) return;
        
        this.currentPath = path;
        this.showLoading();
        
        try {
            const response = await fetch(`/api/file/content?path=${encodeURIComponent(path)}`);
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || `HTTP error ${response.status}`);
            }
            
            const data = await response.json();
            this.render(data);
        } catch (error) {
            console.error('Failed to load file:', error);
            this.showError(error.message);
        }
    }
    
    /**
     * Render content based on file type
     */
    render(data) {
        const { content, type, path, extension } = data;
        
        if (type === 'markdown') {
            this.renderMarkdown(content);
        } else {
            this.renderCode(content, type);
        }
    }
    
    /**
     * Render markdown content with Mermaid diagrams
     */
    renderMarkdown(content) {
        // Pre-process Mermaid blocks
        const mermaidBlocks = [];
        const processedContent = content.replace(
            /```mermaid\n([\s\S]*?)```/g,
            (match, diagram, offset) => {
                const id = `mermaid-${mermaidBlocks.length}`;
                mermaidBlocks.push({ id, diagram: diagram.trim() });
                return `<div class="mermaid" id="${id}"></div>`;
            }
        );
        
        // Parse markdown
        let html;
        if (typeof marked !== 'undefined') {
            html = marked.parse(processedContent);
        } else {
            // Fallback: escape HTML and preserve whitespace
            html = '<pre>' + this.escapeHtml(content) + '</pre>';
        }
        
        // Wrap in markdown-body container
        this.container.innerHTML = `<div class="markdown-body">${html}</div>`;
        
        // Render Mermaid diagrams
        this.renderMermaidDiagrams(mermaidBlocks);
        
        // Apply syntax highlighting to code blocks
        this.highlightCodeBlocks();
    }
    
    /**
     * Render Mermaid diagrams
     */
    async renderMermaidDiagrams(blocks) {
        if (typeof mermaid === 'undefined' || blocks.length === 0) return;
        
        for (const block of blocks) {
            const element = document.getElementById(block.id);
            if (element) {
                try {
                    const { svg } = await mermaid.render(block.id + '-svg', block.diagram);
                    element.innerHTML = svg;
                } catch (error) {
                    console.error('Mermaid render error:', error);
                    element.innerHTML = `<div class="alert alert-warning">
                        <i class="bi bi-exclamation-triangle"></i>
                        Diagram rendering error: ${error.message}
                    </div>`;
                }
            }
        }
    }
    
    /**
     * Apply syntax highlighting to code blocks
     */
    highlightCodeBlocks() {
        if (typeof hljs === 'undefined') return;
        
        this.container.querySelectorAll('pre code').forEach(block => {
            hljs.highlightElement(block);
        });
    }
    
    /**
     * Render code with syntax highlighting
     */
    renderCode(content, type) {
        let highlighted = this.escapeHtml(content);
        
        if (typeof hljs !== 'undefined') {
            try {
                if (type !== 'text' && hljs.getLanguage(type)) {
                    highlighted = hljs.highlight(content, { language: type }).value;
                } else {
                    highlighted = hljs.highlightAuto(content).value;
                }
            } catch (e) {
                console.error('Highlight error:', e);
            }
        }
        
        this.container.innerHTML = `
            <div class="code-viewer">
                <pre><code class="language-${type}">${highlighted}</code></pre>
            </div>
        `;
    }
    
    /**
     * Show loading state
     */
    showLoading() {
        this.container.innerHTML = `
            <div class="content-loading">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
            </div>
        `;
    }
    
    /**
     * Show error message
     */
    showError(message) {
        this.container.innerHTML = `
            <div class="alert alert-danger">
                <i class="bi bi-exclamation-triangle"></i>
                <strong>Error:</strong> ${this.escapeHtml(message)}
            </div>
        `;
    }
    
    /**
     * Escape HTML to prevent XSS
     */
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}

/**
 * Content Editor
 * FEATURE-003: Content Editor
 * 
 * Provides in-place editing of document content via textarea.
 * Integrates with ContentRenderer to switch between view/edit modes.
 */
class ContentEditor {
    constructor(options) {
        this.containerId = options.containerId || 'content-body';
        this.contentRenderer = options.contentRenderer;
        
        // State
        this.isEditing = false;
        this.currentPath = null;
        this.originalContent = null;
        this.hasUnsavedChanges = false;
        
        // DOM elements
        this.container = document.getElementById(this.containerId);
        this.editorActions = document.getElementById('editor-actions');
        this.btnEdit = document.getElementById('btn-edit');
        this.btnSave = document.getElementById('btn-save');
        this.btnCancel = document.getElementById('btn-cancel');
        this.textarea = null;
        
        this._setupEventListeners();
        this._setupKeyboardShortcuts();
        this._setupBeforeUnload();
    }
    
    /**
     * Setup click event listeners for buttons
     */
    _setupEventListeners() {
        if (this.btnEdit) {
            this.btnEdit.addEventListener('click', () => this.startEditing());
        }
        if (this.btnSave) {
            this.btnSave.addEventListener('click', () => this.save());
        }
        if (this.btnCancel) {
            this.btnCancel.addEventListener('click', () => this.cancel());
        }
    }
    
    /**
     * Setup keyboard shortcuts
     */
    _setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Ctrl/Cmd + E: Start editing
            if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
                if (!this.isEditing && this.currentPath) {
                    e.preventDefault();
                    this.startEditing();
                }
            }
            
            // Ctrl/Cmd + S: Save
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                if (this.isEditing) {
                    e.preventDefault();
                    this.save();
                }
            }
            
            // Escape: Cancel editing
            if (e.key === 'Escape') {
                if (this.isEditing) {
                    e.preventDefault();
                    this.cancel();
                }
            }
        });
    }
    
    /**
     * Setup beforeunload handler to warn about unsaved changes
     */
    _setupBeforeUnload() {
        window.addEventListener('beforeunload', (e) => {
            if (this.hasUnsavedChanges) {
                e.preventDefault();
                e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
                return e.returnValue;
            }
        });
    }
    
    /**
     * Set current path when a file is selected
     */
    setCurrentPath(path) {
        // If editing and path changes, warn about unsaved changes
        if (this.isEditing && this.currentPath !== path) {
            if (this.hasUnsavedChanges) {
                const confirm = window.confirm('You have unsaved changes. Do you want to discard them?');
                if (!confirm) {
                    return false;  // Block navigation
                }
            }
            // Cancel current edit
            this._exitEditMode(false);
        }
        
        this.currentPath = path;
        
        // Show edit button when file is loaded
        if (path && this.editorActions) {
            this.editorActions.classList.remove('d-none');
        }
        
        return true;
    }
    
    /**
     * Check if navigation is allowed
     */
    canNavigate() {
        if (this.hasUnsavedChanges) {
            return window.confirm('You have unsaved changes. Do you want to discard them?');
        }
        return true;
    }
    
    /**
     * Start editing the current file
     */
    async startEditing() {
        if (!this.currentPath || this.isEditing) return;
        
        // Fetch raw content
        try {
            const response = await fetch(`/api/file/content?path=${encodeURIComponent(this.currentPath)}`);
            if (!response.ok) {
                throw new Error('Failed to load file content');
            }
            const data = await response.json();
            this.originalContent = data.content;
            
            // Switch to edit mode
            this._enterEditMode(data.content);
            
        } catch (error) {
            console.error('Failed to start editing:', error);
            this._showToast('Failed to load file for editing', 'error');
        }
    }
    
    /**
     * Enter edit mode - show textarea
     */
    _enterEditMode(content) {
        this.isEditing = true;
        
        // Create textarea
        this.textarea = document.createElement('textarea');
        this.textarea.className = 'content-editor-textarea';
        this.textarea.value = content;
        this.textarea.placeholder = 'Enter content...';
        
        // Track changes
        this.textarea.addEventListener('input', () => {
            this.hasUnsavedChanges = this.textarea.value !== this.originalContent;
            this._updateSaveButtonState();
        });
        
        // Replace content with textarea
        this.container.innerHTML = '';
        this.container.appendChild(this.textarea);
        
        // Focus textarea
        this.textarea.focus();
        
        // Update button visibility
        this._updateButtonVisibility(true);
        
        // Disable auto-refresh while editing
        if (window.refreshManager) {
            window.refreshManager.disable();
        }
    }
    
    /**
     * Exit edit mode - restore viewer
     */
    _exitEditMode(rerender = true) {
        this.isEditing = false;
        this.hasUnsavedChanges = false;
        this.textarea = null;
        
        // Update button visibility
        this._updateButtonVisibility(false);
        
        // Re-enable auto-refresh
        if (window.refreshManager) {
            window.refreshManager.enable();
        }
        
        // Re-render content
        if (rerender && this.currentPath && this.contentRenderer) {
            this.contentRenderer.load(this.currentPath);
        }
    }
    
    /**
     * Update button visibility based on edit state
     */
    _updateButtonVisibility(isEditing) {
        if (this.btnEdit) {
            this.btnEdit.classList.toggle('d-none', isEditing);
        }
        if (this.btnSave) {
            this.btnSave.classList.toggle('d-none', !isEditing);
        }
        if (this.btnCancel) {
            this.btnCancel.classList.toggle('d-none', !isEditing);
        }
    }
    
    /**
     * Update save button enabled state
     */
    _updateSaveButtonState() {
        if (this.btnSave) {
            this.btnSave.disabled = !this.hasUnsavedChanges;
        }
    }
    
    /**
     * Save the file
     */
    async save() {
        if (!this.isEditing || !this.currentPath || !this.textarea) return;
        
        const content = this.textarea.value;
        
        // Disable save button during save
        if (this.btnSave) {
            this.btnSave.disabled = true;
            this.btnSave.innerHTML = '<i class="bi bi-hourglass-split"></i> Saving...';
        }
        
        try {
            const response = await fetch('/api/file/save', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    path: this.currentPath,
                    content: content
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                this._showToast('File saved successfully', 'success');
                this.originalContent = content;
                this.hasUnsavedChanges = false;
                
                // Exit edit mode and re-render
                this._exitEditMode(true);
            } else {
                throw new Error(result.error || 'Failed to save file');
            }
            
        } catch (error) {
            console.error('Failed to save file:', error);
            this._showToast(error.message || 'Failed to save file', 'error');
            
            // Restore save button
            if (this.btnSave) {
                this.btnSave.disabled = false;
                this.btnSave.innerHTML = '<i class="bi bi-check-lg"></i> Save';
            }
        }
    }
    
    /**
     * Cancel editing
     */
    cancel() {
        if (!this.isEditing) return;
        
        // Check for unsaved changes
        if (this.hasUnsavedChanges) {
            const confirm = window.confirm('You have unsaved changes. Do you want to discard them?');
            if (!confirm) return;
        }
        
        this._exitEditMode(true);
    }
    
    /**
     * Show toast notification
     */
    _showToast(message, type = 'info') {
        const toastContainer = document.getElementById('toast-container');
        if (!toastContainer) return;
        
        const toast = document.createElement('div');
        toast.className = `toast-notification toast-${type}`;
        
        const icon = type === 'success' ? 'bi-check-circle' : 
                     type === 'error' ? 'bi-exclamation-circle' : 'bi-info-circle';
        
        toast.innerHTML = `
            <i class="bi ${icon}"></i>
            <span>${message}</span>
        `;
        
        toastContainer.appendChild(toast);
        
        // Trigger animation
        setTimeout(() => toast.classList.add('show'), 10);
        
        // Remove after delay
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }
}

/**
 * Workplace Manager
 * FEATURE-008: Workplace (Idea Management)
 * 
 * Two-column view for managing ideas with upload, tree navigation,
 * inline editing with auto-save, and folder rename.
 */
class WorkplaceManager {
    constructor() {
        this.currentView = 'tree'; // tree | upload | editor
        this.currentPath = null;
        this.saveTimer = null;
        this.saveDelay = 5000; // 5 seconds auto-save delay
        this.hasUnsavedChanges = false;
        this.originalContent = '';
        this.renamingFolder = null;
        this.pollInterval = 5000; // 5 seconds tree refresh
        this.pollTimer = null;
        this.lastTreeHash = null;
        this.isActive = false; // Track if workplace view is active
    }
    
    /**
     * Render the workplace view in the content area
     */
    async render(container) {
        this.isActive = true;
        container.innerHTML = `
            <div class="workplace-container">
                <div class="workplace-sidebar">
                    <button class="btn btn-primary workplace-upload-btn" id="workplace-upload-btn">
                        <i class="bi bi-cloud-upload"></i> Upload Idea
                    </button>
                    <div class="workplace-tree" id="workplace-tree">
                        <div class="loading-spinner">
                            <div class="spinner-border spinner-border-sm" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="workplace-content" id="workplace-content">
                    <div class="workplace-placeholder">
                        <i class="bi bi-lightbulb"></i>
                        <h5>Welcome to Workplace</h5>
                        <p class="text-muted">Upload an idea or select a file from the tree</p>
                    </div>
                </div>
            </div>
        `;
        
        // Bind events
        document.getElementById('workplace-upload-btn').addEventListener('click', () => {
            this.showUploadView();
        });
        
        // Load tree and start polling
        await this.loadTree();
        this._startPolling();
    }
    
    /**
     * Stop workplace (called when navigating away)
     */
    stop() {
        this.isActive = false;
        this._stopPolling();
    }
    
    /**
     * Start polling for tree changes
     */
    _startPolling() {
        this._stopPolling(); // Clear any existing timer
        this.pollTimer = setInterval(() => {
            if (this.isActive) {
                this._checkForTreeChanges();
            }
        }, this.pollInterval);
    }
    
    /**
     * Stop polling
     */
    _stopPolling() {
        if (this.pollTimer) {
            clearInterval(this.pollTimer);
            this.pollTimer = null;
        }
    }
    
    /**
     * Check for tree changes and refresh if needed
     */
    async _checkForTreeChanges() {
        try {
            const response = await fetch('/api/ideas/tree');
            const data = await response.json();
            
            if (data.success && data.tree) {
                const newHash = JSON.stringify(data.tree);
                if (this.lastTreeHash && this.lastTreeHash !== newHash) {
                    // Tree changed, refresh it
                    const treeContainer = document.getElementById('workplace-tree');
                    if (treeContainer) {
                        this.renderTree(treeContainer, data.tree);
                        this._showToast('Ideas updated', 'info');
                    }
                }
                this.lastTreeHash = newHash;
            }
        } catch (error) {
            console.error('Failed to check for tree changes:', error);
        }
    }
    
    /**
     * Load and render the idea tree
     */
    async loadTree() {
        const treeContainer = document.getElementById('workplace-tree');
        if (!treeContainer) return;
        
        try {
            const response = await fetch('/api/ideas/tree');
            const data = await response.json();
            
            if (data.success && data.tree) {
                this.lastTreeHash = JSON.stringify(data.tree);
                this.renderTree(treeContainer, data.tree);
            } else {
                this.lastTreeHash = null;
                treeContainer.innerHTML = `
                    <div class="workplace-empty">
                        <i class="bi bi-folder-x"></i>
                        <p>No ideas yet</p>
                    </div>
                `;
            }
        } catch (error) {
            console.error('Failed to load idea tree:', error);
            treeContainer.innerHTML = `
                <div class="workplace-error">
                    <i class="bi bi-exclamation-triangle"></i>
                    <p>Failed to load ideas</p>
                </div>
            `;
        }
    }
    
    /**
     * Render tree nodes recursively
     */
    renderTree(container, nodes, level = 0) {
        if (!nodes || nodes.length === 0) {
            container.innerHTML = `
                <div class="workplace-empty">
                    <i class="bi bi-folder-x"></i>
                    <p>No ideas yet</p>
                </div>
            `;
            return;
        }
        
        const ul = document.createElement('ul');
        ul.className = 'workplace-tree-list';
        if (level === 0) ul.classList.add('workplace-tree-root');
        
        for (const node of nodes) {
            const li = document.createElement('li');
            li.className = 'workplace-tree-item';
            li.dataset.path = node.path;
            li.dataset.type = node.type;
            li.dataset.name = node.name;
            
            const itemContent = document.createElement('div');
            itemContent.className = 'workplace-tree-item-content';
            itemContent.style.paddingLeft = `${level * 16 + 8}px`;
            
            const icon = document.createElement('i');
            icon.className = node.type === 'folder' ? 'bi bi-folder' : 'bi bi-file-earmark';
            
            const nameSpan = document.createElement('span');
            nameSpan.className = 'workplace-tree-name';
            nameSpan.textContent = node.name;
            
            itemContent.appendChild(icon);
            itemContent.appendChild(nameSpan);
            li.appendChild(itemContent);
            
            // Event handlers
            if (node.type === 'file') {
                itemContent.addEventListener('click', () => this.openFile(node.path));
            } else {
                // Folder: click to toggle, double-click to rename (only top-level)
                itemContent.addEventListener('click', (e) => {
                    e.stopPropagation();
                    li.classList.toggle('expanded');
                });
                
                // Only allow rename on top-level idea folders
                if (level === 0) {
                    itemContent.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        this.startFolderRename(li, node.name);
                    });
                }
            }
            
            // Render children
            if (node.children && node.children.length > 0) {
                this.renderTree(li, node.children, level + 1);
                li.classList.add('has-children');
            }
            
            ul.appendChild(li);
        }
        
        container.innerHTML = '';
        container.appendChild(ul);
    }
    
    /**
     * Start inline folder rename
     */
    startFolderRename(li, currentName) {
        if (this.renamingFolder) return;
        
        this.renamingFolder = li;
        const nameSpan = li.querySelector('.workplace-tree-name');
        const originalName = currentName;
        
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'workplace-rename-input';
        input.value = currentName;
        
        nameSpan.replaceWith(input);
        input.focus();
        input.select();
        
        const finishRename = async (save) => {
            if (!this.renamingFolder) return;
            
            const newName = input.value.trim();
            this.renamingFolder = null;
            
            if (save && newName && newName !== originalName) {
                try {
                    const response = await fetch('/api/ideas/rename', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            old_name: originalName,
                            new_name: newName
                        })
                    });
                    
                    const result = await response.json();
                    if (result.success) {
                        this._showToast('Folder renamed successfully', 'success');
                        await this.loadTree();
                    } else {
                        this._showToast(result.error || 'Failed to rename folder', 'error');
                        // Restore original name
                        const newSpan = document.createElement('span');
                        newSpan.className = 'workplace-tree-name';
                        newSpan.textContent = originalName;
                        input.replaceWith(newSpan);
                    }
                } catch (error) {
                    console.error('Failed to rename folder:', error);
                    this._showToast('Failed to rename folder', 'error');
                    const newSpan = document.createElement('span');
                    newSpan.className = 'workplace-tree-name';
                    newSpan.textContent = originalName;
                    input.replaceWith(newSpan);
                }
            } else {
                const newSpan = document.createElement('span');
                newSpan.className = 'workplace-tree-name';
                newSpan.textContent = originalName;
                input.replaceWith(newSpan);
            }
        };
        
        input.addEventListener('blur', () => finishRename(true));
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                finishRename(true);
            } else if (e.key === 'Escape') {
                e.preventDefault();
                finishRename(false);
            }
        });
    }
    
    /**
     * Open a file in the editor
     */
    async openFile(path) {
        // Check for unsaved changes
        if (this.hasUnsavedChanges) {
            if (!window.confirm('You have unsaved changes. Do you want to discard them?')) {
                return;
            }
        }
        
        this.currentView = 'editor';
        this.currentPath = path;
        this.hasUnsavedChanges = false;
        
        const contentArea = document.getElementById('workplace-content');
        contentArea.innerHTML = `
            <div class="workplace-editor">
                <div class="workplace-editor-header">
                    <span class="workplace-editor-path">${this._escapeHtml(path)}</span>
                    <span class="workplace-editor-status" id="workplace-editor-status"></span>
                </div>
                <div class="workplace-editor-loading">
                    <div class="spinner-border spinner-border-sm" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                </div>
            </div>
        `;
        
        try {
            const response = await fetch(`/api/file/content?path=${encodeURIComponent(path)}`);
            const data = await response.json();
            
            this.originalContent = data.content || '';
            this.renderEditor(contentArea, data.content || '');
        } catch (error) {
            console.error('Failed to load file:', error);
            contentArea.innerHTML = `
                <div class="workplace-error">
                    <i class="bi bi-exclamation-triangle"></i>
                    <p>Failed to load file</p>
                </div>
            `;
        }
    }
    
    /**
     * Render the editor with content
     */
    renderEditor(container, content) {
        container.innerHTML = `
            <div class="workplace-editor">
                <div class="workplace-editor-header">
                    <span class="workplace-editor-path">${this._escapeHtml(this.currentPath)}</span>
                    <span class="workplace-editor-status" id="workplace-editor-status"></span>
                </div>
                <textarea class="workplace-editor-textarea" id="workplace-editor-textarea">${this._escapeHtml(content)}</textarea>
            </div>
        `;
        
        const textarea = document.getElementById('workplace-editor-textarea');
        textarea.addEventListener('input', () => {
            this.onContentChange();
        });
    }
    
    /**
     * Handle content change - schedule auto-save
     */
    onContentChange() {
        this.hasUnsavedChanges = true;
        this.updateStatus('modified');
        
        // Clear existing timer
        if (this.saveTimer) {
            clearTimeout(this.saveTimer);
        }
        
        // Schedule save after 5 seconds
        this.saveTimer = setTimeout(() => {
            this.saveContent();
        }, this.saveDelay);
    }
    
    /**
     * Save the current content
     */
    async saveContent() {
        if (!this.currentPath || !this.hasUnsavedChanges) return;
        
        const textarea = document.getElementById('workplace-editor-textarea');
        if (!textarea) return;
        
        const content = textarea.value;
        this.updateStatus('saving');
        
        try {
            const response = await fetch('/api/file/save', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    path: this.currentPath,
                    content: content
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                this.originalContent = content;
                this.hasUnsavedChanges = false;
                this.updateStatus('saved');
                
                // Clear saved status after 2 seconds
                setTimeout(() => {
                    if (!this.hasUnsavedChanges) {
                        this.updateStatus('');
                    }
                }, 2000);
            } else {
                throw new Error(result.error || 'Failed to save');
            }
        } catch (error) {
            console.error('Failed to save file:', error);
            this.updateStatus('error');
            this._showToast('Failed to save file', 'error');
        }
    }
    
    /**
     * Update editor status indicator
     */
    updateStatus(status) {
        const statusEl = document.getElementById('workplace-editor-status');
        if (!statusEl) return;
        
        switch (status) {
            case 'modified':
                statusEl.innerHTML = '<i class="bi bi-circle-fill text-warning"></i> Modified';
                break;
            case 'saving':
                statusEl.innerHTML = '<i class="bi bi-arrow-repeat spin"></i> Saving...';
                break;
            case 'saved':
                statusEl.innerHTML = '<i class="bi bi-check-circle-fill text-success"></i> Saved';
                break;
            case 'error':
                statusEl.innerHTML = '<i class="bi bi-exclamation-circle-fill text-danger"></i> Save failed';
                break;
            default:
                statusEl.innerHTML = '';
        }
    }
    
    /**
     * Show upload view
     */
    showUploadView() {
        // Check for unsaved changes
        if (this.hasUnsavedChanges) {
            if (!window.confirm('You have unsaved changes. Do you want to discard them?')) {
                return;
            }
        }
        
        this.currentView = 'upload';
        this.currentPath = null;
        this.hasUnsavedChanges = false;
        
        const contentArea = document.getElementById('workplace-content');
        contentArea.innerHTML = `
            <div class="workplace-uploader">
                <div class="workplace-dropzone" id="workplace-dropzone">
                    <i class="bi bi-cloud-upload"></i>
                    <h5>Drag & Drop Files Here</h5>
                    <p class="text-muted">or click to browse</p>
                    <input type="file" id="workplace-file-input" multiple style="display: none;">
                </div>
                <div class="workplace-upload-status d-none" id="workplace-upload-status">
                    <div class="spinner-border spinner-border-sm" role="status"></div>
                    <span>Uploading...</span>
                </div>
            </div>
        `;
        
        this.setupUploader();
    }
    
    /**
     * Setup upload event handlers
     */
    setupUploader() {
        const dropzone = document.getElementById('workplace-dropzone');
        const fileInput = document.getElementById('workplace-file-input');
        
        if (!dropzone || !fileInput) return;
        
        // Click to browse
        dropzone.addEventListener('click', () => {
            fileInput.click();
        });
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                this.uploadFiles(e.target.files);
            }
        });
        
        // Drag and drop
        dropzone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropzone.classList.add('dragover');
        });
        
        dropzone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dropzone.classList.remove('dragover');
        });
        
        dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropzone.classList.remove('dragover');
            
            if (e.dataTransfer.files.length > 0) {
                this.uploadFiles(e.dataTransfer.files);
            }
        });
    }
    
    /**
     * Upload files to the server
     */
    async uploadFiles(files) {
        const statusEl = document.getElementById('workplace-upload-status');
        const dropzone = document.getElementById('workplace-dropzone');
        
        if (statusEl) statusEl.classList.remove('d-none');
        if (dropzone) dropzone.classList.add('uploading');
        
        try {
            const formData = new FormData();
            for (const file of files) {
                formData.append('files', file);
            }
            
            const response = await fetch('/api/ideas/upload', {
                method: 'POST',
                body: formData
            });
            
            const result = await response.json();
            
            if (result.success) {
                this._showToast(`Uploaded ${result.files_uploaded.length} file(s) to ${result.folder_name}`, 'success');
                await this.loadTree();
                
                // Show placeholder after successful upload
                const contentArea = document.getElementById('workplace-content');
                contentArea.innerHTML = `
                    <div class="workplace-placeholder">
                        <i class="bi bi-check-circle text-success"></i>
                        <h5>Upload Complete</h5>
                        <p class="text-muted">Files uploaded to ${this._escapeHtml(result.folder_name)}</p>
                    </div>
                `;
            } else {
                throw new Error(result.error || 'Upload failed');
            }
        } catch (error) {
            console.error('Upload failed:', error);
            this._showToast(error.message || 'Upload failed', 'error');
            
            if (statusEl) statusEl.classList.add('d-none');
            if (dropzone) dropzone.classList.remove('uploading');
        }
    }
    
    /**
     * Show toast notification
     */
    _showToast(message, type = 'info') {
        const toastContainer = document.getElementById('toast-container');
        if (!toastContainer) return;
        
        const toast = document.createElement('div');
        toast.className = `toast-notification toast-${type}`;
        
        const icon = type === 'success' ? 'bi-check-circle' : 
                     type === 'error' ? 'bi-exclamation-circle' : 'bi-info-circle';
        
        toast.innerHTML = `
            <i class="bi ${icon}"></i>
            <span>${message}</span>
        `;
        
        toastContainer.appendChild(toast);
        
        // Trigger animation
        setTimeout(() => toast.classList.add('show'), 10);
        
        // Remove after delay
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }
    
    /**
     * Escape HTML special characters
     */
    _escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text || '';
        return div.innerHTML;
    }
}

/**
 * Content Refresh Manager
 * FEATURE-004: Live Refresh (Polling Implementation)
 * 
 * Handles automatic content refresh when files change on disk.
 * Uses HTTP polling every 5 seconds to detect changes.
 */
class ContentRefreshManager {
    constructor(options) {
        this.contentRenderer = options.contentRenderer;
        this.enabled = this._loadEnabledState();
        this.scrollPosition = 0;
        this.lastContent = null;
        this.lastPath = null;
        this.pollInterval = 5000; // 5 seconds
        this.pollTimer = null;
        
        this._setupToggleListener();
        this._updateToggleUI();
        this._startPolling();
    }
    
    /**
     * Load enabled state from localStorage
     */
    _loadEnabledState() {
        const saved = localStorage.getItem('autoRefreshEnabled');
        return saved === null ? true : saved === 'true';
    }
    
    /**
     * Save enabled state to localStorage
     */
    _saveEnabledState() {
        localStorage.setItem('autoRefreshEnabled', this.enabled.toString());
    }
    
    /**
     * Setup toggle UI listener
     */
    _setupToggleListener() {
        const toggle = document.getElementById('auto-refresh-toggle');
        if (toggle) {
            toggle.addEventListener('change', (e) => {
                this.setEnabled(e.target.checked);
            });
        }
    }
    
    /**
     * Update toggle UI to match current state
     */
    _updateToggleUI() {
        const toggle = document.getElementById('auto-refresh-toggle');
        if (toggle) {
            toggle.checked = this.enabled;
        }
    }
    
    /**
     * Start polling loop
     */
    _startPolling() {
        console.log('[ContentRefreshManager] Starting polling (every 5s)');
        this.pollTimer = setInterval(() => {
            this._checkForChanges();
        }, this.pollInterval);
    }
    
    /**
     * Check for content changes via HTTP polling
     */
    async _checkForChanges() {
        if (!this.enabled) return;
        
        const currentPath = this.contentRenderer?.currentPath;
        if (!currentPath) return;
        
        // Skip if path changed - reset tracking
        if (currentPath !== this.lastPath) {
            this.lastContent = null;
            this.lastPath = currentPath;
            return;
        }
        
        // Skip planning files (handled by PlanningFilePoller)
        if (/planning[\/\\](task-board|features)\.md$/i.test(currentPath)) {
            return;
        }
        
        try {
            const response = await fetch(`/api/file/content?path=${encodeURIComponent(currentPath)}`);
            
            if (!response.ok) {
                // File might be deleted
                if (response.status === 404) {
                    this._handleFileDeletion();
                }
                return;
            }
            
            const data = await response.json();
            const newContent = data.content;
            
            // First load - just cache
            if (this.lastContent === null) {
                this.lastContent = newContent;
                return;
            }
            
            // Check if content changed
            if (this.lastContent !== newContent) {
                console.log('[ContentRefreshManager] Content changed, refreshing...');
                this.lastContent = newContent;
                this._refreshContent(data);
            }
        } catch (error) {
            console.error('[ContentRefreshManager] Poll error:', error);
        }
    }
    
    /**
     * Handle file deletion
     */
    _handleFileDeletion() {
        const container = this.contentRenderer?.container;
        if (container) {
            container.innerHTML = `
                <div class="alert alert-warning d-flex flex-column align-items-center justify-content-center h-100 m-4">
                    <i class="bi bi-file-earmark-x display-4 mb-3"></i>
                    <h5>File Not Found</h5>
                    <p class="text-muted text-center">
                        The file you were viewing has been deleted or moved.
                    </p>
                    <button class="btn btn-outline-primary" onclick="window.projectSidebar?.load()">
                        <i class="bi bi-folder2-open"></i> Browse Files
                    </button>
                </div>
            `;
        }
        this.lastContent = null;
        this.lastPath = null;
    }
    
    /**
     * Refresh the content view with scroll preservation
     */
    _refreshContent(data) {
        const contentBody = document.getElementById('content-body');
        this.scrollPosition = contentBody ? contentBody.scrollTop : 0;
        
        // Re-render using ContentRenderer
        if (this.contentRenderer) {
            this.contentRenderer.render(data);
        }
        
        // Restore scroll position
        if (contentBody) {
            requestAnimationFrame(() => {
                const maxScroll = contentBody.scrollHeight - contentBody.clientHeight;
                contentBody.scrollTop = Math.min(this.scrollPosition, maxScroll);
            });
        }
        
        // Show refresh indicator
        this._showRefreshIndicator();
    }
    
    /**
     * Refresh the current content (public method)
     */
    async refresh() {
        const currentPath = this.contentRenderer?.currentPath;
        if (!currentPath) return;
        
        // Save scroll position
        const contentBody = document.getElementById('content-body');
        this.scrollPosition = contentBody ? contentBody.scrollTop : 0;
        
        try {
            // Reload content
            await this.contentRenderer.load(currentPath);
            
            // Restore scroll position
            if (contentBody) {
                const maxScroll = contentBody.scrollHeight - contentBody.clientHeight;
                contentBody.scrollTop = Math.min(this.scrollPosition, maxScroll);
            }
            
            // Update cached content
            const response = await fetch(`/api/file/content?path=${encodeURIComponent(currentPath)}`);
            if (response.ok) {
                const data = await response.json();
                this.lastContent = data.content;
            }
            
            this._showRefreshIndicator();
        } catch (error) {
            console.error('Refresh failed:', error);
        }
    }
    
    /**
     * Show visual indicator that content was refreshed
     */
    _showRefreshIndicator() {
        const container = document.getElementById('toast-container');
        if (!container) return;
        
        const toast = document.createElement('div');
        toast.className = 'refresh-toast';
        toast.innerHTML = `
            <i class="bi bi-arrow-repeat"></i>
            Content updated
        `;
        
        container.appendChild(toast);
        setTimeout(() => toast.remove(), 2500);
    }
    
    /**
     * Set auto-refresh enabled state
     */
    setEnabled(enabled) {
        this.enabled = enabled;
        this._saveEnabledState();
        this._updateToggleUI();
    }
    
    /**
     * Disable auto-refresh (called when editing)
     */
    disable() {
        this.enabled = false;
        this._updateToggleUI();
    }
    
    /**
     * Enable auto-refresh (called after editing)
     */
    enable() {
        this.enabled = this._loadEnabledState();
        this._updateToggleUI();
    }
    
    /**
     * Get current enabled state
     */
    isEnabled() {
        return this.enabled;
    }
}

/**
 * Planning File Poller
 * 
 * Automatically polls for updates on planning files (task-board.md, features.md)
 * every 5 seconds to ensure the latest content is always displayed.
 * Uses simple HTTP polling - no sockets.
 */
class PlanningFilePoller {
    constructor(options) {
        this.pollInterval = options.pollInterval || 5000; // 5 seconds
        this.lastContent = null;
        this.lastPath = null;
        // Match any path ending with these filenames
        this.planningFilePatterns = [
            /planning[\/\\]task-board\.md$/i,
            /planning[\/\\]features\.md$/i
        ];
        
        // Start the polling loop immediately
        this._startPollingLoop();
    }
    
    /**
     * Check if a path is a planning file
     */
    isPlanningFile(path) {
        if (!path) return false;
        return this.planningFilePatterns.some(pattern => pattern.test(path));
    }
    
    /**
     * Get the currently viewed file path from ContentRenderer
     */
    getCurrentPath() {
        return window.contentRenderer?.currentPath || null;
    }
    
    /**
     * Start the main polling loop - runs forever
     */
    _startPollingLoop() {
        console.log('[PlanningFilePoller] Starting polling loop (every 5s)');
        
        setInterval(() => {
            this._checkAndRefresh();
        }, this.pollInterval);
    }
    
    /**
     * Check current file and refresh if needed
     */
    async _checkAndRefresh() {
        const currentPath = this.getCurrentPath();
        
        // Reset if path changed
        if (currentPath !== this.lastPath) {
            this.lastContent = null;
            this.lastPath = currentPath;
        }
        
        // Only poll planning files
        if (!this.isPlanningFile(currentPath)) {
            return;
        }
        
        console.log(`[PlanningFilePoller] Checking ${currentPath}...`);
        
        try {
            const response = await fetch(`/api/file/content?path=${encodeURIComponent(currentPath)}`);
            if (!response.ok) return;
            
            const data = await response.json();
            const newContent = data.content;
            
            // First load - just store content
            if (this.lastContent === null) {
                console.log('[PlanningFilePoller] Initial content cached');
                this.lastContent = newContent;
                return;
            }
            
            // Check if content changed
            if (this.lastContent !== newContent) {
                console.log('[PlanningFilePoller] Content CHANGED! Refreshing...');
                this.lastContent = newContent;
                this._refreshContent(data);
            }
        } catch (error) {
            console.error('[PlanningFilePoller] Error:', error);
        }
    }
    
    /**
     * Refresh the content view with scroll preservation
     */
    _refreshContent(data) {
        const contentBody = document.getElementById('content-body');
        const scrollTop = contentBody ? contentBody.scrollTop : 0;
        
        // Re-render using ContentRenderer
        if (window.contentRenderer) {
            window.contentRenderer.render(data);
        }
        
        // Restore scroll position
        if (contentBody) {
            requestAnimationFrame(() => {
                const maxScroll = contentBody.scrollHeight - contentBody.clientHeight;
                contentBody.scrollTop = Math.min(scrollTop, maxScroll);
            });
        }
        
        // Show toast notification
        this._showToast();
    }
    
    /**
     * Show refresh notification
     */
    _showToast() {
        const container = document.getElementById('toast-container');
        if (!container) return;
        
        const toast = document.createElement('div');
        toast.className = 'refresh-toast';
        toast.innerHTML = '<i class="bi bi-arrow-clockwise"></i> Updated';
        container.appendChild(toast);
        
        setTimeout(() => toast.remove(), 2500);
    }
}

/**
 * Project Switcher
 * FEATURE-006 v2.0: Multi-Project Folder Support
 * 
 * Loads project folders from API and handles switching between projects.
 * When a project is switched, it refreshes the sidebar.
 */
class ProjectSwitcher {
    constructor(selectId, onSwitch) {
        this.select = document.getElementById(selectId);
        this.onSwitch = onSwitch;
        this.projects = [];
        this.activeProjectId = null;
        
        this.bindEvents();
        this.load();
    }
    
    bindEvents() {
        this.select.addEventListener('change', (e) => this.handleSwitch(e));
    }
    
    async load() {
        try {
            const response = await fetch('/api/projects');
            const data = await response.json();
            
            this.projects = data.projects;
            this.activeProjectId = data.active_project_id;
            this.render();
        } catch (error) {
            console.error('Failed to load projects:', error);
            this.select.innerHTML = '<option value="">Failed to load</option>';
        }
    }
    
    render() {
        if (this.projects.length === 0) {
            this.select.innerHTML = '<option value="">No projects</option>';
            return;
        }
        
        this.select.innerHTML = this.projects.map(project => {
            const isActive = project.id === this.activeProjectId;
            return `<option value="${project.id}" ${isActive ? 'selected' : ''}>
                ${isActive ? ' ' : ''}${this.escapeHtml(project.name)}
            </option>`;
        }).join('');
    }
    
    async handleSwitch(e) {
        const projectId = parseInt(e.target.value);
        if (!projectId || projectId === this.activeProjectId) return;
        
        try {
            const response = await fetch('/api/projects/switch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ project_id: projectId })
            });
            
            const data = await response.json();
            
            if (data.success) {
                this.activeProjectId = data.active_project_id;
                this.render();
                
                // Show toast
                this.showToast(`Switched to ${data.project.name}`);
                
                // Callback to refresh sidebar
                if (this.onSwitch) {
                    this.onSwitch(data.project);
                }
            } else {
                console.error('Switch failed:', data.error);
                this.showToast('Failed to switch project', 'danger');
            }
        } catch (error) {
            console.error('Switch error:', error);
            this.showToast('Network error', 'danger');
        }
    }
    
    showToast(message, type = 'success') {
        const container = document.getElementById('toast-container');
        if (!container) return;
        
        const toast = document.createElement('div');
        toast.className = type === 'success' ? 'refresh-toast' : 'refresh-toast bg-danger';
        toast.innerHTML = `<i class="bi bi-folder-check"></i> ${this.escapeHtml(message)}`;
        container.appendChild(toast);
        
        setTimeout(() => toast.remove(), 2500);
    }
    
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}

/**
 * Project Sidebar Navigation
 * FEATURE-001: Project Navigation (Polling Implementation)
 * 
 * Uses HTTP polling every 5 seconds to detect structure changes.
 */
class ProjectSidebar {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.selectedFile = null;
        this.sections = [];
        this.lastStructureHash = null;
        this.pollInterval = 5000; // 5 seconds
        
        // FEATURE-009: Track changed paths for visual indicator
        this.changedPaths = new Set();
        this.previousPaths = new Set();
        
        this._startPolling();
    }
    
    /**
     * Start polling for structure changes
     */
    _startPolling() {
        console.log('[ProjectSidebar] Starting structure polling (every 5s)');
        setInterval(() => {
            this._checkForChanges();
        }, this.pollInterval);
    }
    
    /**
     * Check for structure changes via HTTP polling
     */
    async _checkForChanges() {
        try {
            const response = await fetch('/api/project/structure');
            if (!response.ok) return;
            
            const data = await response.json();
            const newHash = this._hashStructure(data.sections);
            
            // First load - initialize paths
            if (this.lastStructureHash === null) {
                this.lastStructureHash = newHash;
                this.previousPaths = this._extractAllPaths(data.sections);
                return;
            }
            
            // Check if structure changed
            if (this.lastStructureHash !== newHash) {
                console.log('[ProjectSidebar] Structure changed, detecting changes...');
                
                // FEATURE-009: Detect which paths changed
                const currentPaths = this._extractAllPaths(data.sections);
                this._detectChangedPaths(this.previousPaths, currentPaths);
                
                this.lastStructureHash = newHash;
                this.previousPaths = currentPaths;
                this.sections = data.sections;
                this.render();
                this.showToast('File structure updated', 'info');
            }
        } catch (error) {
            console.error('[ProjectSidebar] Poll error:', error);
        }
    }
    
    /**
     * Create a simple hash of the structure for comparison
     */
    _hashStructure(sections) {
        return JSON.stringify(sections);
    }
    
    // =========================================================================
    // FEATURE-009: File Change Indicator
    // =========================================================================
    
    /**
     * Extract all file/folder paths from structure
     */
    _extractAllPaths(sections) {
        const paths = new Set();
        
        const traverse = (items) => {
            for (const item of items) {
                if (item.path) {
                    paths.add(item.path);
                }
                if (item.children) {
                    traverse(item.children);
                }
            }
        };
        
        for (const section of sections) {
            if (section.children) {
                traverse(section.children);
            }
        }
        
        return paths;
    }
    
    /**
     * Detect changed paths between old and new structure
     */
    _detectChangedPaths(oldPaths, newPaths) {
        // Find new paths (added)
        for (const path of newPaths) {
            if (!oldPaths.has(path)) {
                console.log('[ProjectSidebar] New path detected:', path);
                this._addChangedPath(path);
            }
        }
        
        // Find removed paths (mark parent as changed)
        for (const path of oldPaths) {
            if (!newPaths.has(path)) {
                console.log('[ProjectSidebar] Removed path detected:', path);
                const parent = this._getParentPath(path);
                if (parent) {
                    this._addChangedPath(parent);
                }
            }
        }
    }
    
    /**
     * Add path and bubble up to parents
     */
    _addChangedPath(path) {
        if (!path) return;
        
        this.changedPaths.add(path);
        
        // Bubble up to parents
        const parts = path.split('/');
        for (let i = parts.length - 1; i > 0; i--) {
            const parentPath = parts.slice(0, i).join('/');
            this.changedPaths.add(parentPath);
        }
    }
    
    /**
     * Clear path and cleanup parents if no changed children
     */
    _clearChangedPath(path) {
        if (!this.changedPaths.has(path)) return;
        
        this.changedPaths.delete(path);
        console.log('[ProjectSidebar] Cleared change indicator for:', path);
        
        // Check parents - clear if no other changed children
        const parts = path.split('/');
        for (let i = parts.length - 1; i > 0; i--) {
            const parentPath = parts.slice(0, i).join('/');
            if (!this._hasChangedChildren(parentPath)) {
                this.changedPaths.delete(parentPath);
                console.log('[ProjectSidebar] Cleared parent indicator for:', parentPath);
            }
        }
    }
    
    /**
     * Check if folder has any changed children
     */
    _hasChangedChildren(folderPath) {
        const prefix = folderPath + '/';
        for (const path of this.changedPaths) {
            if (path.startsWith(prefix)) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Get parent path
     */
    _getParentPath(path) {
        const parts = path.split('/');
        if (parts.length <= 1) return null;
        return parts.slice(0, -1).join('/');
    }
    
    /**
     * Load project structure from API
     */
    async load() {
        try {
            const response = await fetch('/api/project/structure');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            this.sections = data.sections;
            this.lastStructureHash = this._hashStructure(data.sections);
            this.previousPaths = this._extractAllPaths(data.sections);
            this.render();
        } catch (error) {
            console.error('Failed to load project structure:', error);
            this.container.innerHTML = `
                <div class="nav-empty text-danger">
                    <i class="bi bi-exclamation-triangle"></i> Failed to load project structure
                </div>
            `;
        }
    }
    
    /**
     * Render the navigation tree
     */
    render() {
        if (!this.sections || this.sections.length === 0) {
            this.container.innerHTML = '<div class="nav-empty">No sections found</div>';
            return;
        }
        
        let html = '';
        
        for (const section of this.sections) {
            html += this.renderSection(section);
        }
        
        this.container.innerHTML = html;
        this.bindEvents();
    }
    
    /**
     * Render a single section
     */
    renderSection(section) {
        const icon = section.icon || 'bi-folder';
        const hasChildren = section.children && section.children.length > 0;
        
        // Special handling for Workplace section - no expandable content
        if (section.id === 'workplace') {
            return `
                <div class="nav-section" data-section-id="${section.id}">
                    <div class="nav-section-header nav-workplace-header" data-section-id="${section.id}">
                        <i class="bi ${icon}"></i>
                        <span>${section.label}</span>
                    </div>
                </div>
            `;
        }
        
        let html = `
            <div class="nav-section" data-section-id="${section.id}">
                <div class="nav-section-header" data-bs-toggle="collapse" data-bs-target="#section-${section.id}">
                    <i class="bi ${icon}"></i>
                    <span>${section.label}</span>
                    <i class="bi bi-chevron-down chevron"></i>
                </div>
                <div class="collapse show nav-section-content" id="section-${section.id}">
        `;
        
        if (!section.exists) {
            html += '<div class="nav-empty">Folder not found</div>';
        } else if (!hasChildren) {
            html += '<div class="nav-empty">No files</div>';
        } else {
            html += this.renderChildren(section.children);
        }
        
        html += '</div></div>';
        return html;
    }
    
    /**
     * Render children (files and folders)
     */
    renderChildren(children, depth = 0) {
        if (!children || children.length === 0) {
            return '';
        }
        
        let html = '';
        const indent = depth * 1; // rem
        
        for (const item of children) {
            if (item.type === 'folder') {
                html += this.renderFolder(item, depth);
            } else {
                html += this.renderFile(item, depth);
            }
        }
        
        return html;
    }
    
    /**
     * Render a folder item
     */
    renderFolder(folder, depth) {
        const folderId = folder.path.replace(/[\/\.]/g, '-');
        const hasChildren = folder.children && folder.children.length > 0;
        const paddingLeft = 2 + (depth * 0.75);
        const isChanged = this.changedPaths.has(folder.path);
        
        let html = `
            <div class="nav-item nav-folder${isChanged ? ' has-changes' : ''}" 
                 style="padding-left: ${paddingLeft}rem"
                 data-bs-toggle="collapse" 
                 data-bs-target="#folder-${folderId}"
                 data-path="${folder.path}">
                ${isChanged ? '<span class="change-indicator"></span>' : ''}
                <i class="bi bi-folder"></i>
                <span>${folder.name}</span>
                ${hasChildren ? '<i class="bi bi-chevron-down chevron ms-auto" style="font-size: 0.7rem;"></i>' : ''}
            </div>
        `;
        
        if (hasChildren) {
            html += `
                <div class="collapse show nav-folder-content" id="folder-${folderId}">
                    ${this.renderChildren(folder.children, depth + 1)}
                </div>
            `;
        }
        
        return html;
    }
    
    /**
     * Render a file item
     */
    renderFile(file, depth) {
        const icon = this.getFileIcon(file.name);
        const paddingLeft = 2 + (depth * 0.75);
        const isActive = this.selectedFile === file.path;
        const isChanged = this.changedPaths.has(file.path);
        
        return `
            <div class="nav-item nav-file${isActive ? ' active' : ''}${isChanged ? ' has-changes' : ''}" 
                 style="padding-left: ${paddingLeft}rem"
                 data-path="${file.path}">
                ${isChanged ? '<span class="change-indicator"></span>' : ''}
                <i class="bi ${icon}"></i>
                <span>${file.name}</span>
            </div>
        `;
    }
    
    /**
     * Get icon for file type
     */
    getFileIcon(filename) {
        const ext = filename.split('.').pop().toLowerCase();
        const icons = {
            'md': 'bi-file-earmark-text',
            'py': 'bi-filetype-py',
            'js': 'bi-filetype-js',
            'ts': 'bi-filetype-tsx',
            'html': 'bi-filetype-html',
            'css': 'bi-filetype-css',
            'json': 'bi-filetype-json',
            'yaml': 'bi-file-code',
            'yml': 'bi-file-code',
            'txt': 'bi-file-text'
        };
        return icons[ext] || 'bi-file-earmark';
    }
    
    /**
     * Bind click events to file items
     */
    bindEvents() {
        // File click events
        const fileItems = this.container.querySelectorAll('.nav-file');
        fileItems.forEach(item => {
            item.addEventListener('click', (e) => {
                // Remove active from all
                fileItems.forEach(f => f.classList.remove('active'));
                // Add active to clicked
                item.classList.add('active');
                
                const path = item.dataset.path;
                this.selectedFile = path;
                
                // FEATURE-009: Clear change indicator for this file
                if (this.changedPaths.has(path)) {
                    this._clearChangedPath(path);
                    // Update UI - remove indicator and class
                    item.classList.remove('has-changes');
                    const indicator = item.querySelector('.change-indicator');
                    if (indicator) indicator.remove();
                    // Update parent folders if needed
                    this._updateParentIndicators(path);
                }
                
                this.onFileSelect(path);
            });
        });
        
        // Workplace section click handler
        const workplaceHeader = this.container.querySelector('.nav-workplace-header');
        if (workplaceHeader) {
            workplaceHeader.addEventListener('click', () => {
                // Clear file selection
                fileItems.forEach(f => f.classList.remove('active'));
                this.selectedFile = null;
                
                // Update breadcrumb
                const breadcrumb = document.getElementById('breadcrumb');
                breadcrumb.innerHTML = '<li class="breadcrumb-item active">Workplace</li>';
                
                // Render WorkplaceManager view
                const container = document.getElementById('content-body');
                if (window.workplaceManager) {
                    window.workplaceManager.render(container);
                }
            });
        }
        
        // Section header collapse tracking
        const sectionHeaders = this.container.querySelectorAll('.nav-section-header:not(.nav-workplace-header)');
        sectionHeaders.forEach(header => {
            const target = document.querySelector(header.dataset.bsTarget);
            if (target) {
                target.addEventListener('hide.bs.collapse', () => {
                    header.classList.add('collapsed');
                });
                target.addEventListener('show.bs.collapse', () => {
                    header.classList.remove('collapsed');
                });
            }
        });
    }
    
    /**
     * FEATURE-009: Update parent folder indicators after clearing a file
     */
    _updateParentIndicators(path) {
        const parts = path.split('/');
        for (let i = parts.length - 1; i > 0; i--) {
            const parentPath = parts.slice(0, i).join('/');
            if (!this.changedPaths.has(parentPath)) {
                // Find and update the parent folder element
                const parentEl = this.container.querySelector(`.nav-folder[data-path="${parentPath}"]`);
                if (parentEl) {
                    parentEl.classList.remove('has-changes');
                    const indicator = parentEl.querySelector('.change-indicator');
                    if (indicator) indicator.remove();
                }
            }
        }
    }
    
    /**
     * Handle file selection - loads content via ContentRenderer
     */
    onFileSelect(path) {
        console.log('File selected:', path);
        
        // Stop workplace polling when navigating to a file
        if (window.workplaceManager) {
            window.workplaceManager.stop();
        }
        
        // Check with ContentEditor if navigation is allowed (unsaved changes)
        if (window.contentEditor) {
            const canNavigate = window.contentEditor.setCurrentPath(path);
            if (!canNavigate) {
                return;  // Navigation blocked due to unsaved changes
            }
        }
        
        // Update breadcrumb
        const breadcrumb = document.getElementById('breadcrumb');
        const parts = path.split('/');
        breadcrumb.innerHTML = parts.map((part, index) => {
            const isLast = index === parts.length - 1;
            return `<li class="breadcrumb-item ${isLast ? 'active' : ''}">${part}</li>`;
        }).join('');
        
        // Load content via ContentRenderer
        if (window.contentRenderer) {
            window.contentRenderer.load(path);
        }
        
        // Emit custom event for other components
        const event = new CustomEvent('fileSelected', { detail: { path } });
        document.dispatchEvent(event);
    }
    
    /**
     * Show toast notification
     */
    showToast(message, type = 'info') {
        const container = document.getElementById('toast-container');
        const toastId = 'toast-' + Date.now();
        
        const bgClass = {
            'info': 'bg-info',
            'success': 'bg-success',
            'warning': 'bg-warning',
            'error': 'bg-danger'
        }[type] || 'bg-info';
        
        const toastHtml = `
            <div id="${toastId}" class="toast ${bgClass} text-white" role="alert">
                <div class="toast-body d-flex align-items-center">
                    <span>${message}</span>
                    <button type="button" class="btn-close btn-close-white ms-auto" data-bs-dismiss="toast"></button>
                </div>
            </div>
        `;
        
        container.insertAdjacentHTML('beforeend', toastHtml);
        const toastEl = document.getElementById(toastId);
        const toast = new bootstrap.Toast(toastEl, { delay: 3000 });
        toast.show();
        
        toastEl.addEventListener('hidden.bs.toast', () => {
            toastEl.remove();
        });
    }
}

// Initialize sidebar, content renderer, and terminal panel on page load
document.addEventListener('DOMContentLoaded', () => {
    // Initialize content renderer (FEATURE-002)
    const contentRenderer = new ContentRenderer('content-body');
    window.contentRenderer = contentRenderer;
    
    // Initialize content editor (FEATURE-003)
    const contentEditor = new ContentEditor({
        containerId: 'content-body',
        contentRenderer: contentRenderer
    });
    window.contentEditor = contentEditor;
    
    // Initialize workplace manager (FEATURE-008)
    const workplaceManager = new WorkplaceManager();
    window.workplaceManager = workplaceManager;
    
    // Initialize planning file poller (5s HTTP polling for task-board.md & features.md)
    // Standalone - no sockets, just polls every 5 seconds
    const planningPoller = new PlanningFilePoller({
        pollInterval: 5000  // 5 seconds
    });
    window.planningPoller = planningPoller;
    
    // Initialize sidebar (FEATURE-001)
    const sidebar = new ProjectSidebar('sidebar-content');
    sidebar.load();
    
    // Make sidebar globally accessible
    window.projectSidebar = sidebar;
    
    // Initialize project switcher (FEATURE-006 v2.0)
    const projectSwitcher = new ProjectSwitcher('project-select', (project) => {
        // When project is switched, reload the sidebar and clear content
        sidebar.load();
        contentRenderer.container.innerHTML = `
            <div class="content-placeholder">
                <i class="bi bi-folder-check"></i>
                <h5>Switched to ${projectSwitcher.escapeHtml(project.name)}</h5>
                <p class="text-muted">Select a file from the sidebar to view</p>
            </div>
        `;
    });
    window.projectSwitcher = projectSwitcher;
    
    // Initialize content refresh manager (FEATURE-004 - Polling)
    // Uses HTTP polling every 5 seconds - no WebSocket dependency
    const refreshManager = new ContentRefreshManager({
        contentRenderer: contentRenderer
    });
    window.refreshManager = refreshManager;
    
    // Initialize terminal panel (FEATURE-005)
    // TerminalManager and TerminalPanel are defined in /static/js/terminal.js
    const terminalManager = new TerminalManager('terminal-panes');
    terminalManager.initialize();
    const terminalPanel = new TerminalPanel(terminalManager);
    window.terminalManager = terminalManager;
    window.terminalPanel = terminalPanel;
});
</script>
{% endblock %}